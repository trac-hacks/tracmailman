from trac.config import ListOption
from trac.core import *
from trac.web import chrome
from trac.web.chrome import INavigationContributor, ITemplateProvider
from trac.web.main import IRequestHandler
from trac.perm import IPermissionRequestor
from trac.util import escape, Markup

import sys # Workaround for: http://trac.edgewall.org/ticket/5628
import os.path
import re
import getopt
import paths

import SwishE

from genshi.input import HTML
from genshi.filters import HTMLSanitizer


def authenticated(req):
    """
    Verify the user is logged in
    """
    if (not req.session.authenticated) or (req.authname == 'anonymous'):
        chrome.add_warning(req, 'Please log in')
        return False
    return True

class MailManPluginIndex(Component):
    """
    The main page of the TracMailman plugin. This displays the search box,
    with a drop-down list of all the mailing lists to search by, as well as
    a list of the mailing archives for manual browsing.
    """
    implements(INavigationContributor, IRequestHandler, ITemplateProvider, IPermissionRequestor)

    # IPermissionRequestor methods
    def get_permission_actions(self):
        return ['MAILMAN_VIEW',('MAILMAN_ADMIN', ['MAILMAN_VIEW'])]

    # INavigationContributor methods
    def get_active_navigation_item(self, req):
        return 'tracmailman'

    def get_navigation_items(self, req):
        """
        Display a tab for TracMailMan at the top nav bar
        """
        if req.perm.has_permission("MAILMAN_VIEW"):
            yield 'mainnav', 'tracmailman', Markup('<a href="%s">Mailing Lists</a>' % (self.env.href.tracmailman()))
        else:
            yield 'mainnav', 'tracmailman', None

    # IRequestHandler methods
    def match_request(self, req):
        """
        This plugin handles requests for the path
        example.com/trac_top_dir/tracmailman/browser/
        """
        return re.match(r'^/tracmailman$', req.path_info)


    def process_request(self, req):
        req.perm.require("MAILMAN_VIEW")
        # The full path to where the mailman archives are stored
        mail_archive_path = self.env.config.get('tracmailman', 'mail_archive_path')
        if mail_archive_path[-1] != '/':
            mail_archive_path += '/'

        data = {}
        data['title'] = 'Mailing List Search'
        # The default content is an error message. If the code below
        # is successful, it will replace the error with real content
        data['contents'] = 'An error has occured. Please hit "Back" on your browser and try again.'

        if not authenticated(req):
            return 'tracmailman.html', data, 'text/html'
        else:
            data['authenticated'] = True

        # The list of mailing list archives
        data['mail_archives'] = []
        data['priv_archives'] = []
        data['pub_archives'] = []

        # Add mailing lists to be displayed in the search and browser
        for privarchive in os.listdir(mail_archive_path + 'private'):
            if privarchive not in self.env.config.getlist('tracmailman', 'private_lists') and privarchive[-4:] != "mbox":
                data['priv_archives'].append(privarchive)
        for pubarchive in os.listdir(mail_archive_path + 'public'):
            if pubarchive not in self.env.config.getlist('tracmailman', 'private_lists') and pubarchive[-4:] != "mbox" and pubarchive not in data['priv_archives']:
                data['pub_archives'].append(pubarchive)
        data['mail_archives'] = data['priv_archives'] + data['pub_archives']
        data['mail_archives'].sort()
        return 'tracmailman.html', data, 'text/html'

    # ITemplateProvider methods
    def get_htdocs_dirs(self):
        from pkg_resources import resource_filename
        return [('tracmailman', resource_filename(__name__, 'templates'))]

    def get_templates_dirs(self):
        from pkg_resources import resource_filename
        return [resource_filename(__name__, 'templates')]


class MailManPluginBrowser(Component):
    """
    Takes a request and serves the correct document.  A request such
    as
    example.com/trac/tracmilman/browser/private/example_list/23.html
    would be understood to be a request for example_list's private
    archive, email message 23. Other than mail messages, a user can
    also request indices such as thread.html, subject.html,
    author.html and date.html . These are all documents generated by
    MailMan's Pipermail.

    The plugin will first verify that this user is a member of
    example_list. Then it will load the HTML document from disk by
    looking in the path specified by the mail_archive_path variable in
    trac.ini , and keep only the HTML tags between the <body></body>.

    This data is fed through a HTML sanitizer that comes with
    Trac/Genshi, and finally, the sanitized HTML is put in a Trac
    template to preserve the look and feel of the Trac interface.

    """
    implements(IRequestHandler, ITemplateProvider, IPermissionRequestor)

    # IPermissionRequestor methods
    def get_permission_actions(self):
        return ['MAILMAN_VIEW',('MAILMAN_ADMIN', ['MAILMAN_VIEW'])]

    # IRequestHandler methods
    def match_request(self, req):
        """
        This plugin handles requests for the path
        example.com/trac_top_dir/tracmailman/browser/
        """
        return re.match(r'^/tracmailman/browser/', req.path_info)


    def process_request(self, req):
        req.perm.require("MAILMAN_VIEW")
        # This is a workaround for bug: http://trac.edgewall.org/ticket/5628
        reload(sys)
        if sys.getdefaultencoding() == 'ascii':
            sys.setdefaultencoding("latin1")
        # End: workaround

        # The full path to where the mailman archives are stored
        mail_archive_path = self.env.config.get('tracmailman', 'mail_archive_path')
        if mail_archive_path[-1] != '/':
            mail_archive_path += "/"

        data = {}
        data['title'] = 'Mailing List Archive Browser'

        # Check user is logged in
        if not authenticated(req):
            return 'tracmailmanbrowser.html', data, 'text/html'
        else:
            data['authenticated'] = True

        # We won't respond to just anything. Let's use regexps to pull
        # out relevant tokens, and verify the tokens.
        doctypes = '((\d+)|(thread)|(subject)|(author)|(date))'
        result = re.search(r'^/tracmailman/browser/(public|private)/([^/]+)/([^.]+)\.(html|txt|txt\.gz)$', req.path_info)
        if result is None:
            chrome.add_warning(req, 'The URL you requested is does not refer to a valid document')
            return 'tracmailmanbrowser.html', data, 'text/html'

        priv     = result.group(1)
        listname = result.group(2)
        docID    = result.group(3)
        extension= result.group(4)

        # Check if user is trying to access a private list
        if listname in self.env.config.getlist('tracmailman', 'private_lists'):
            chrome.add_warning(req, 'This list is private and not browsable. Please go through the standard Mailman interface.')
            return 'tracmailmanbrowser.html', data, 'text/html'


        path = mail_archive_path + priv + '/' + listname + '/' + docID + '.' + extension
        if os.path.isfile(path):
            archivedMail = open(path, 'r').read()
            if extension == 'html':
                html = HTML(archivedMail,encoding='utf-8')
                # At this point, the HTML document is turned into a Genshi
                # object. For more info on how to transform the HTML
                # object using Genshi:
                # http://genshi.edgewall.org/wiki/ApiDocs
                #
                sanitized = html.select('body/*') | HTMLSanitizer()
                contents = sanitized.render('html')
                contents = re.sub(r'<a name=.+?a>',"",contents)
                data['contents'] = Markup(contents)
                data['title'] += " - " + listname
                return 'tracmailmanbrowser.html', data, 'text/html'
            else:
                req.send_response(200)
                if extension == 'txt':
                    req.send_header('Content-Type', 'text/plain')
                else:
                    req.send_header('Content-Type', 'application/x-gzip')
                req.send_header('Content-Length', len(archivedMail))
                req.end_headers()
                req.write(archivedMail)

        else:
            if docID in ['thread', 'subject', 'author', 'date']:
                chrome.add_warning(req,
                                   """You requested a mail index page
                                   that could not be found.  It is
                                   possible that there are currently
                                   no mail messages archived, so no
                                   index has been created."""
                                   )
            else:
                chrome.add_warning(req, 'The mail message that you requested cannot be found')

            return 'tracmailmanbrowser.html', data, 'text/html'

    # ITemplateProvider methods
    def get_htdocs_dirs(self):
        from pkg_resources import resource_filename
        return [('tracmailman', resource_filename(__name__, 'templates'))]

    def get_templates_dirs(self):
        from pkg_resources import resource_filename
        return [resource_filename(__name__, 'templates')]


class TracMailManSearchPlugin(Component):
    implements(IRequestHandler, ITemplateProvider, IPermissionRequestor)

    # IPermissionRequestor methods
    def get_permission_actions(self):
        return ['MAILMAN_VIEW',('MAILMAN_ADMIN', ['MAILMAN_VIEW'])]

    # IRequestHandler methods
    def match_request(self, req):
        """
        This plugin handles requests for the path
        example.com/trac_top_dir/tracmailman/search
        """
        return req.path_info == '/tracmailman/search'


    def process_request(self, req):
        req.perm.require("MAILMAN_VIEW")
        # This is a workaround for bug: http://trac.edgewall.org/ticket/5628
        reload(sys)
        if sys.getdefaultencoding() == 'ascii':
            sys.setdefaultencoding("latin1")
        # End: workaround

        # The full path to where the mailman archives are stored
        mail_archive_path = self.env.config.get('tracmailman', 'mail_archive_path')
        if mail_archive_path[-1] != '/':
            mail_archive_path += '/'

        # The full path to where the indices are stored
        search_index_path = self.env.config.get('tracmailman', 'search_index_path')
        if search_index_path[-1] != '/':
            search_index_path += '/'

        # The private archives not to be searched
        private_archives = self.env.config.getlist('tracmailman', 'private_lists')

        data = {}
        data['title'] = 'Mailing List Search'

        # Check the user is logged in
        if not authenticated(req):
            return 'tracmailmansearch.html', data, 'text/html'
        else:
            data['authenticated'] = True

        # Add mailing lists to be displayed in the search
        data['mail_archives'] = []

        for privarchive in os.listdir(mail_archive_path + 'private'):
            if privarchive not in private_archives and privarchive[-4:] != "mbox":
                data['mail_archives'].append(privarchive)
        for pubarchive in os.listdir(mail_archive_path + 'public'):
            if pubarchive not in private_archives and pubarchive[-4:] != "mbox" and pubarchive not in data['mail_archives']:
                data['mail_archives'].append(pubarchive)
        data['mail_archives'].sort()

        # Grab the search query
        if req.args.has_key('query') and req.args['query'].strip():
            query = req.args['query']
            data['query'] = query
        else:
            chrome.add_warning(req, 'Please enter a query.')
            return 'tracmailmansearch.html', data, 'text/html'

        # Grab which list the user searched
        if req.args.has_key('search_list'):
            search_list = req.args['search_list']
            data['search_list'] = search_list
        else:
            chrome.add_warning(req, 'Please select a list to search from.')
            return 'tracmailmansearch.html', data, 'text/html'

        # Get the search index for the particular list the user selected
        swishIndex  = search_index_path + search_list + '-index.swish-e'

        try:
            handle = SwishE.new(swishIndex)
        except Exception, e:
            chrome.add_warning(req, 'Search index not found. Please contact the administrator for help.')
            return 'tracmailmansearch.html', data, 'text/html'

        # Run the query using the search engine
        try:
            swishResults = handle.query(query)
        except Exception, e:
            chrome.add_warning(req, 'Bad query: e.message')
            return 'tracmailmansearch.html', data, 'text/html'

        # The number of hits
        #numHits = swishResults.hits()

        # If we searched all the mailing lists, remove the ones from the private lists
        #if search_list == 'all':
        #    for result in swishResults:
        #        msg = result.getproperty('swishdocpath')
        #        for private_list in private_archives:
        #            if private_list in msg:
        #                numHits -= 1
        #
        #data['numHits'] = numHits


        ordered_results = []
        for swishResult in swishResults:
            title = swishResult.getproperty('swishtitle')
            regex = re.match(r'^\[(.+?)\s(\d+)\].*', title)
            if regex is None:
                continue
            list_name = regex.group(1)
            list_num = int(regex.group(2))
            # If we searched all the mailing lists, remove the ones from the private lists
            if search_list == 'all' and list_name in private_archives:
                continue
            # Obtain the mailing list number for this mail
            ordered_results.append((list_num,swishResult))
        ordered_results.sort()
        ordered_results = [result[1] for result in ordered_results]
        numHits = len(ordered_results)
        data['numHits'] = numHits

        if numHits == 0:
            return 'tracmailmansearch.html', data, 'text/html'

        # page and hitsPerPage are to control pagination
        hitsPerPage = 20
        if req.args.has_key('page'):
            # For usability we want to let the user see "page=1", but
            # in reality, this maps to the 0th page
            page = int(req.args['page']) - 1
        else:
            page = 0

        data['currentPage'] = page
        data['maxPage'] = numHits / hitsPerPage
        if numHits % hitsPerPage > 0:
            data['maxPage'] += 1

        results = []
        firstHit = page * hitsPerPage
        data['firstHit'] = firstHit
        data['lastHit'] = min(firstHit + hitsPerPage, numHits)
        swishResults.seek(firstHit)
        seen = 0
        while((seen < hitsPerPage) and (firstHit + seen < numHits)):
            seen += 1
            #sr = swishResults.next()
            sr = ordered_results[firstHit + seen - 1]
            hit = {}
            diskPath = sr.getproperty('swishdocpath')
            # Check if this msg is from a private list; if so, discard it
            #valid = True
            #for private_archive in private_archives:
            #    if private_archive in diskPath:
            #        valid = False
            #        seen -= 1
            #        break
            #if not valid:
            #    continue

            webPath = diskPath.lstrip(mail_archive_path)
            # Just in case there is still a leading '/'
            webPath = webPath.lstrip('/')
            hit['path'] = 'browser/' + webPath
            # The rest of the data
            hit['number'] = firstHit + seen
            hit['title'] = sr.getproperty('swishtitle')
            hit['description'] = sr.getproperty('swishdescription')
            results.append(hit)

        data['results'] = results
        data['title'] += " - " + '"' + query + '"'
        return 'tracmailmansearch.html', data, 'text/html'


    # ITemplateProvider methods
    def get_htdocs_dirs(self):
        from pkg_resources import resource_filename
        return [('tracswishe', resource_filename(__name__, 'templates'))]


    def get_templates_dirs(self):
        from pkg_resources import resource_filename
        return [resource_filename(__name__, 'templates')]


